# -*- coding: utf-8 -*-
"""report_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1reLL26JrdA7SLTVhCj5EvXf7UhYXXRTx
"""

import streamlit as st
import pandas as pd
import datetime
import io
import xlrd
from openpyxl import Workbook
from PIL import Image
import base64
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import time
import os

st.set_page_config(page_title="WFTP Project", layout="wide")

uploaded_file = st.file_uploader("Upload file Excel", type=["xlsx", "xls"])

# Load referensi zona dari file lokal
try:
    df_zona = pd.read_excel("referensi_zona.xlsx", sheet_name="Zona")
    try:
        df_zona_ps1 = pd.read_excel("referensi_zona.xlsx", sheet_name="Zona PS1")
    except:
        df_zona_ps1 = pd.DataFrame(columns=["MID", "ZONA"])
except Exception as e:
    st.error(f"Gagal load data referensi zona: {e}")
    st.stop()

# Manual Input: Wavepick dan Running Time di dua kolom terpisah
manual_wavepicks = set()
manual_running_time = {}

st.subheader("Manual Input Wavepick & Running Time")
col1, col2 = st.columns(2)
with col1:
    wavepick_input = st.text_area("Masukkan daftar Wavepick", placeholder="9017464713\n9017464698")
with col2:
    runningtime_input = st.text_area("Masukkan daftar Running Time", placeholder="21 Apr 2025 10:00:26\n21 Apr 2025 10:13:04")

if wavepick_input and runningtime_input:
    wavepick_lines = wavepick_input.strip().splitlines()
    runningtime_lines = runningtime_input.strip().splitlines()

    if len(wavepick_lines) == len(runningtime_lines):
        for wp, rt in zip(wavepick_lines, runningtime_lines):
            wp = wp.strip()
            rt_parsed = pd.to_datetime(rt.strip(), errors='coerce', dayfirst=True)
            if wp and pd.notnull(rt_parsed):
                manual_wavepicks.add(wp)
                manual_running_time[wp] = rt_parsed
        # Preview input manual
        preview_df = pd.DataFrame.from_dict(manual_running_time, orient='index', columns=['Running Time'])
        preview_df.index.name = 'Wavepick'
        preview_df = preview_df.reset_index()
        st.subheader("‚úÖ Preview Input Manual yang Tervalidasi")

        # Show more or less toggle
        show_more = st.checkbox("See more", value=False)
        if not show_more:
            preview_df = preview_df.head(3)
        st.dataframe(preview_df, use_container_width=True)
        if show_more:
            st.write("See less")
        else:
            st.write("See more")
    else:
        st.warning("Jumlah baris Wavepick dan Running Time tidak sama.")

def convert_xls_to_xlsx(uploaded_file):
    try:
        book = xlrd.open_workbook(file_contents=uploaded_file.read())
        sheet = book.sheet_by_index(0)
        wb = Workbook()
        ws = wb.active
        for row_idx in range(sheet.nrows):
            ws.append(sheet.row_values(row_idx))
        output = io.BytesIO()
        wb.save(output)
        output.seek(0)
        return output
    except Exception as e:
        st.error("Gagal konversi file .xls. Mohon upload ulang dalam format .xlsx")
        st.stop()

if uploaded_file:
    try:
        if uploaded_file.name.endswith(".xls"):
            xlsx_file = convert_xls_to_xlsx(uploaded_file)
            df_raw = pd.read_excel(xlsx_file, sheet_name=0)
        else:
            df_raw = pd.read_excel(uploaded_file, sheet_name=0)
    except Exception as e:
        st.error(f"Gagal baca sheet dari file user: {e}")
        st.stop()

    df = df_raw.copy()
    df.columns = df.columns.str.strip()

    column_mapping = {
        'Confirm Date': 'Confirm date',
        'Confirm Time': 'Confirm time',
        'Qty': 'Qty',
        'Flag': 'Flag',
        'Wavepick Created': 'Wavepick created',
        'Wavepick No': 'Wavepick',
        'Stype': 'STYPE',
        'Material ID': 'MID',
        'Description': 'Description'
    }
    df = df.rename(columns=column_mapping)

    required_columns = list(column_mapping.values())
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        st.error(f"File yang diupload tidak mengandung kolom berikut: {', '.join(missing_columns)}")
        st.stop()

    df['Wavepick'] = df['Wavepick'].astype(str)
    df['Confirm date'] = pd.to_datetime(df['Confirm date'], errors='coerce')
    df['Confirm time'] = pd.to_datetime(df['Confirm time'], errors='coerce').dt.time
    df['Wavepick created'] = pd.to_datetime(df['Wavepick created'], errors='coerce')
    df['Confirm datetime'] = pd.to_datetime(df['Confirm date'].astype(str) + ' ' + df['Confirm time'].astype(str), errors='coerce')

    stype_to_zona = df_zona.groupby('STYPE')['ZONA'].first().to_dict()
    df['ZONA'] = df['STYPE'].map(stype_to_zona)
    df = df.merge(df_zona_ps1, on='MID', how='left', suffixes=('', '_ps1'))
    df['ZONA'] = df['ZONA_ps1'].combine_first(df['ZONA'])
    df = df.drop(columns=['ZONA_ps1'])

    zona_map = {
        'ZAA': 'A',
        'ZAB': 'BK',
        'ZAC': 'CJ',
        'ZAL': 'L'
    }
    df['ZONA'] = df['ZONA'].replace(zona_map)
    df['ZONA'] = df['ZONA'].fillna('Unmapped')

    df['TimeStr'] = df['Confirm datetime'].dt.time.astype(str)
    valid_confirm = df[(df['Confirm datetime'].notna()) & (df['TimeStr'] != '00:00:00')].copy()

    wavepick_c = valid_confirm[valid_confirm['Flag'] == 'C']

    if manual_wavepicks:
        wavepick_c = wavepick_c[wavepick_c['Wavepick'].isin(manual_wavepicks)]

    if wavepick_c.empty:
        st.warning("Tidak ditemukan data Wavepick dengan Flag 'C' yang sesuai input manual.")
        st.stop()

    rekap_wavepick = wavepick_c.groupby('Wavepick').agg(
        Last_Confirm=('Confirm datetime', 'max'),
        Total_Qty=('Qty', 'sum'),
        Total_MID=('MID', 'nunique')
    ).reset_index()

    rekap_wavepick['Start_Confirm'] = rekap_wavepick['Wavepick'].map(manual_running_time)
    rekap_wavepick = rekap_wavepick[rekap_wavepick['Start_Confirm'].notna()]
    rekap_wavepick['First_Confirm'] = rekap_wavepick['Start_Confirm']
    rekap_wavepick['Durasi_td'] = rekap_wavepick['Last_Confirm'] - rekap_wavepick['First_Confirm']
    rekap_wavepick['Durasi'] = rekap_wavepick['Durasi_td'].apply(lambda x: str(x).split('.')[0])

    last_confirm_per_wavepick = wavepick_c.loc[wavepick_c.groupby('Wavepick')['Confirm datetime'].idxmax()]
    last_confirm_zona_map = last_confirm_per_wavepick.set_index('Wavepick')['ZONA'].to_dict()
    rekap_wavepick['ZONA'] = rekap_wavepick['Wavepick'].map(last_confirm_zona_map)

    rata2_durasi = rekap_wavepick['Durasi_td'].mean()
    rata2_durasi_str = str(rata2_durasi).split('.')[0]

    operator_df = wavepick_c[wavepick_c['STYPE'] == 'RB1'].copy()
    operator_df['Wavepick_Start'] = operator_df['Wavepick'].map(manual_running_time)
    operator_df['Wavepick_Start'] = pd.to_datetime(operator_df['Wavepick_Start'], errors='coerce')
    operator_df['Durasi'] = operator_df['Confirm datetime'] - operator_df['Wavepick_Start']
    operator_summary = operator_df.groupby('Wavepick').agg(
        Qty=('Qty', 'sum'),
        MID=('MID', 'nunique'),
        Durasi_td=('Durasi', 'max')
    ).reset_index()
    operator_summary['Durasi'] = operator_summary['Durasi_td'].apply(lambda x: str(x).split('.')[0])
    operator_summary = operator_summary.drop(columns='Durasi_td')

    rata2_durasi_operator = pd.to_timedelta(operator_df['Durasi']).mean()
    durasi_operator_str = str(rata2_durasi_operator).split('.')[0]

    # TABS
    tab1, tab2, tab3, tab4, tab5 = st.tabs(["üìÑ Overview", "‚è±Ô∏è Top Durasi", "üó∫Ô∏è Zona Summary", "üë∑ Operator Summary", "‚ùóBelum Diinput"])

    with tab1:
        st.metric("üî¢ Total Wavepick Berjalan", len(rekap_wavepick))
        st.caption(f"Total SPKB running yang sudah dikonfirmasi: {rekap_wavepick['Wavepick'].nunique()} SPKB")
        col_d1, col_d2 = st.columns(2)
        with col_d1:
            st.metric("üì¶ Rata-rata Durasi Picking per Wavepick", rata2_durasi_str)
        with col_d2:
            st.metric("üë∑ Rata-rata Durasi Picking Operator", durasi_operator_str)

    with tab2:
        st.subheader("üìä Top 3 Wavepick dengan Durasi Tertinggi")
        st.dataframe(rekap_wavepick.sort_values("Durasi_td", ascending=False).head(3)[['Wavepick', 'Durasi', 'ZONA']], use_container_width=True)

    with tab3:
        st.subheader("üìà Rata-rata Durasi & Kontribusi per Zona")
        zona_summary = rekap_wavepick.groupby("ZONA").agg(
            Rata_rata_Durasi=('Durasi_td', 'mean'),
            Count_Last_Confirm=('Wavepick', 'count')
        ).reset_index()
        zona_summary['Rata_rata_Durasi'] = zona_summary['Rata_rata_Durasi'].apply(lambda x: str(x).split('.')[0])
        st.dataframe(zona_summary, use_container_width=True)

    with tab4:
        st.subheader("üë∑ Rangkuman Picking Operator")
        st.dataframe(operator_summary, use_container_width=True)

    with tab5:
        semua_wavepick_excel = set(df['Wavepick'].unique())
        belum_diinput = sorted(list(semua_wavepick_excel - manual_wavepicks))
        if belum_diinput:
            st.subheader("üîî Wavepick Belum Diinput Manual")
            st.write(f"Total: {len(belum_diinput)}")
            st.dataframe(pd.DataFrame({'Wavepick': belum_diinput}), use_container_width=True)
        else:
            st.success("Semua Wavepick sudah diinput manual.")

# Fitur Share sebagai Gambar atau Link
show_share_section = st.checkbox("üîó Tampilkan Menu Share Ringkasan")
if show_share_section:
    st.info("Fitur ini memungkinkan Anda membagikan hasil dengan cara mudah.")
    st.markdown("- Gunakan tombol screenshot browser untuk mengambil tampilan dashboard sebagai gambar.")
    st.markdown("- Atau deploy app ini dan kirimkan URL dashboard ke pihak terkait.")

# Capture Screenshot Functionality using Selenium
def capture_screenshot():
    # Setting up Selenium with Chrome
    chrome_options = Options()
    chrome_options.add_argument("--headless")  # Run Chrome in headless mode
    driver = webdriver.Chrome(options=chrome_options)

    # Open the Streamlit URL
    driver.get('http://localhost:8501')  # Make sure Streamlit is running on localhost:8501

    # Wait for the page to load completely
    time.sleep(5)

    # Capture the screenshot
    screenshot_path = "wavepick_dashboard.png"
    driver.save_screenshot(screenshot_path)

    # Close the browser window
    driver.quit()

    return screenshot_path

# Button to trigger screenshot capture
if st.button("Capture Screenshot Dashboard"):
    screenshot_path = capture_screenshot()

    # Provide download link for the screenshot
    with open(screenshot_path, "rb") as file:
        btn = st.download_button(
            label="Download Screenshot",
            data=file,
            file_name="wavepick_dashboard.png",
            mime="image/png"
        )